#include <SPI.h>
#include <MFRC522.h>
#include <Wire.h>
#include <LiquidCrystal_I2C.h>
#include <Keypad.h>
#include <EEPROM.h>

#define RST_PIN 9
#define SS_PIN 10
#define RELAY_PIN 7
#define BUZZER_PIN 3
#define FLOW_SENSOR_PIN 2

// تعريف هيكل بيانات المعايرة
struct CalibrationData {
  float factor;
  float lastAccuracy;
  int samplesCount;
};

// تعريف المتغيرات العامة
LiquidCrystal_I2C lcd(0x27, 16, 2);
MFRC522 mfrc522(SS_PIN, RST_PIN);

volatile int pulseCount = 0;
float flowRate = 0.0;
float totalLiters = 0.0;
float targetLiters = 0.0;
unsigned long lastTime = 0;
unsigned long startTime = 0;
float CALIBRATION_FACTOR = 7.5;
const float AUTO_CALIBRATION_RATIO = 0.2;
const int CALIB_HISTORY_SIZE = 5;
float calibrationHistory[CALIB_HISTORY_SIZE];
int historyIndex = 0;

// تعريف لوحة المفاتيح
const byte ROWS = 4;
const byte COLS = 4;
char keys[ROWS][COLS] = {
  {'1','2','3','A'},
  {'4','5','6','B'},
  {'7','8','9','C'},
  {'*','0','#','D'}
};
byte rowPins[ROWS] = {A0, A1, A2, A3};
byte colPins[COLS] = {4, 5, 6, 8};
Keypad keypad = Keypad(makeKeymap(keys), rowPins, colPins, ROWS, COLS);

// تعريف البطاقة المصرح بها
byte authorizedCard[] = {0x43, 0xCB, 0x96, 0xA0};

// تعريف الدوال
void pulseCounter();
void beep(int freq, int duration);
String calculateElapsedTime(unsigned long startMillis);
void resetSystem();
void handleWaterFlow();
void autoCalibrate(float knownVolume);

void setup() {
  Serial.begin(9600);
  SPI.begin();
  mfrc522.PCD_Init();
  
  lcd.init();
  lcd.backlight();
  
  pinMode(RELAY_PIN, OUTPUT);
  pinMode(BUZZER_PIN, OUTPUT);
  pinMode(FLOW_SENSOR_PIN, INPUT_PULLUP);
  
  digitalWrite(RELAY_PIN, LOW);
  attachInterrupt(digitalPinToInterrupt(FLOW_SENSOR_PIN), pulseCounter, FALLING);

  // تحميل بيانات المعايرة من الذاكرة
  CalibrationData savedData;
  EEPROM.get(0, savedData);
  
  if(!isnan(savedData.factor) && savedData.factor > 0) {
    CALIBRATION_FACTOR = savedData.factor;
    for(int i=0; i<CALIB_HISTORY_SIZE; i++) {
      calibrationHistory[i] = CALIBRATION_FACTOR;
    }
  }

  lcd.clear();
  lcd.print("System Ready");
}

void loop() {
  // الكود الرئيسي هنا
}

// تعريف الدوال المساعدة
void pulseCounter() {
  pulseCount++;
}

void beep(int freq, int duration) {
  tone(BUZZER_PIN, freq, duration);
  delay(duration);
  noTone(BUZZER_PIN);
}

String calculateElapsedTime(unsigned long startMillis) {
  unsigned long elapsed = (millis() - startMillis) / 1000;
  int hours = elapsed / 3600;
  int minutes = (elapsed % 3600) / 60;
  int seconds = elapsed % 60;

  char buffer[9];
  sprintf(buffer, "%02d:%02d:%02d", hours, minutes, seconds);
  return String(buffer);
}

void resetSystem() {
  digitalWrite(RELAY_PIN, LOW);
  lcd.clear();
  lcd.print("System Ready");
  totalLiters = 0;
  targetLiters = 0;
}

void handleWaterFlow() {
  if (millis() - lastTime >= 1000) {
    detachInterrupt(digitalPinToInterrupt(FLOW_SENSOR_PIN));
    
    float timeDelta = (millis() - lastTime) / 1000.0;
    flowRate = (pulseCount / CALIBRATION_FACTOR) / timeDelta;
    totalLiters += flowRate / 60.0;
    
    // تحديث العرض
    lcd.clear();
    lcd.print("Filling...");
    lcd.setCursor(0, 1);
    lcd.print(String(totalLiters, 3) + "/" + String(targetLiters) + "L");
    lcd.setCursor(11, 0);
    lcd.print(calculateElapsedTime(startTime));

    if (totalLiters >= targetLiters * 0.98) {
      digitalWrite(RELAY_PIN, LOW);
      delay(300);
      
      detachInterrupt(digitalPinToInterrupt(FLOW_SENSOR_PIN));
      totalLiters += (pulseCount / CALIBRATION_FACTOR) / 60.0;
      
      if(targetLiters > 0.5 && targetLiters < 20) {
        autoCalibrate(targetLiters);
      }
      
      beep(1000, 500);
      lcd.clear();
      lcd.print("Filling Complete!");
      lcd.setCursor(0, 1);
      lcd.print(String(totalLiters, 3) + "L in " + calculateElapsedTime(startTime));
      delay(3000);
      resetSystem();
    }
    
    pulseCount = 0;
    lastTime = millis();
    attachInterrupt(digitalPinToInterrupt(FLOW_SENSOR_PIN), pulseCounter, FALLING);
  }
}

void autoCalibrate(float knownVolume) {
  float measuredVolume = totalLiters;
  float errorRatio = measuredVolume / knownVolume;
  
  if(errorRatio < 0.7 || errorRatio > 1.5) return;
  
  float newFactor = CALIBRATION_FACTOR * errorRatio;
  CALIBRATION_FACTOR = CALIBRATION_FACTOR * (1 - AUTO_CALIBRATION_RATIO) + newFactor * AUTO_CALIBRATION_RATIO;
  
  calibrationHistory[historyIndex] = CALIBRATION_FACTOR;
  historyIndex = (historyIndex + 1) % CALIB_HISTORY_SIZE;
  
  float avgFactor = 0;
  for(int i=0; i<CALIB_HISTORY_SIZE; i++) {
    avgFactor += calibrationHistory[i];
  }
  avgFactor /= CALIB_HISTORY_SIZE;
  
  CalibrationData toSave;
  toSave.factor = avgFactor;
  toSave.lastAccuracy = abs(1 - (measuredVolume / knownVolume));
  toSave.samplesCount = CALIB_HISTORY_SIZE;
  
  EEPROM.put(0, toSave);
  
  lcd.clear();
  lcd.print("Auto-Calibration");
  lcd.setCursor(0, 1);
  lcd.print("New Factor: " + String(avgFactor, 2));
  delay(2000);
}
